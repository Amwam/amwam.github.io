<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1" data-next-head=""/><meta property="og:image" content="https://amwam.me/images/me.png" data-next-head=""/><link rel="manifest" href="/manifest.json" data-next-head=""/><link rel="alternate" type="application/rss+xml" title="RSS" href="https://amwam.me/rss.xml" data-next-head=""/><title data-next-head="">Maintaining a clean Git history | AMWAM - Amit Shah</title><meta property="og:url" content="https://amwam.me/blog/maintaining-a-clean-git-history" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Maintaining a clean Git history | AMWAM - Amit Shah" data-next-head=""/><meta property="og:image" content="https://amwam.me/images/me.png" data-next-head=""/><meta property="article:published_time" content="2015-10-11" data-next-head=""/><meta property="article:author" content="Amit Shah" data-next-head=""/><link rel="preload" href="/_next/static/chunks/dd9a78eca37df397.css" as="style"/><link rel="preload" href="/_next/static/chunks/274988711c50b9b5.css" as="style"/><link rel="stylesheet" href="/_next/static/chunks/dd9a78eca37df397.css" data-n-g=""/><link rel="stylesheet" href="/_next/static/chunks/274988711c50b9b5.css" data-n-p=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/9a04d3721f770a18.js" defer=""></script><script src="/_next/static/chunks/47a270e501e65340.js" defer=""></script><script src="/_next/static/chunks/28d7fb3b5b7550cd.js" defer=""></script><script src="/_next/static/chunks/181061b33a699bc3.js" defer=""></script><script src="/_next/static/chunks/turbopack-4a60034fd93a4310.js" defer=""></script><script src="/_next/static/chunks/72551891c21528a4.js" defer=""></script><script src="/_next/static/chunks/bc4441a87401806d.js" defer=""></script><script src="/_next/static/chunks/turbopack-87c3e0d3863916bc.js" defer=""></script><script src="/_next/static/65UyYX_pAZroMRbCqWvbZ/_ssgManifest.js" defer=""></script><script src="/_next/static/65UyYX_pAZroMRbCqWvbZ/_buildManifest.js" defer=""></script></head><body><div id="__next"><div class="_app-module__3RcuBW__container"><div id="Navigation-module__KYCJma__nav-bar" role="navigation"><img id="Navigation-module__KYCJma__nav-display-picture" src="/images/me.200.png" alt="Me (Amit)" loading="lazy"/><div id="Navigation-module__KYCJma__name">Amit Shah</div><div id="Navigation-module__KYCJma__nav-links"><div class="Navigation-module__KYCJma__nav-link"><a href="/">Home</a></div><div class="Navigation-module__KYCJma__nav-link"><a href="/about">About</a></div><div class="Navigation-module__KYCJma__nav-link"><a href="/blog">Blog</a></div><div class="Navigation-module__KYCJma__nav-link"><a href="/contact">Contact</a></div></div></div><div id="_app-module__3RcuBW__content-wrapper"><main id="_app-module__3RcuBW__content"><div><h1>Maintaining a clean Git history</h1><h4>11 October 2015</h4><div class="style-module__c7Ehta__tags"><span><a href="/blog?tag=git">git</a></span></div><p>Ensuring the git history of your project (or any version controlled project) can be an incredibly useful asset.
In particular for new developers, trying to understand why code has been written in a certain way.
With clear and ordered commit messages, it can become obvious as to why a change was made.</p>
<p>There are two practices I apply to make sure that I leave my code changes as clear as I can.
They are how I write the commit messages, and the
ordering of the actual commits.</p>
<h3>Commit messages</h3>
<p>The message in a commit is where an explanation for the change should reside.
This should include at the very least what was changed, and why.</p>
<p>Some examples of a bad commit messages include (and yes, I have seen these kind of commits from multiple developers on different projects):</p>
<blockquote>
<p>fixed bug</p>
</blockquote>
<p>and</p>
<blockquote>
<p>refactored stuff</p>
</blockquote>
<p>A more descriptive commit message would look something like</p>
<blockquote>
<p>Fix ImageProcessingFactory not handling images less than 50px wide</p>
</blockquote>
<p>Commit messages should ideally tell you what a commit will do if it is applied.
I try to write my messages as if being read as <code>This commit will &lt;commit message&gt;</code></p>
<p>An even better commit message would have a slightly longer message, after the initial message, describing the problem/change in more detail.
However, this isn&#x27;t always practical or even necessary depending on the project.
If you have a chance I would recommend taking a look at the git and linux kernal commit messages as examples of great ones!</p>
<p>I&#x27;ve also worked in places that would prepend the ticket number to the commit message. Allowing developers to view the reasons for a change in more
detail.</p>
<h3>Autosquashing commits</h3>
<p>Rebasing commit allows you to keep your history linear.
While not everyone agrees whether or not you should be maintaining a linear history,
It is almost definitely (in my opinion) and good idea to keep your local branches ordered appropriately, by showing changes as a series of changes to be applied.
Ideally each change is isolated from the others (within reason), and can be applied separately.</p>
<p>Development rarely works like this. Too often have I made some changes, progressed a bit further, and realised I there were more changes to make in
that original commit.
Maybe it was a left over debug statement, or some missing config, or even a chunk of functionality I didn&#x27;t originally think about.
Typically most people would just make a new commit with these changes, and leave it at that.</p>
<p>Git has the ability to squash commits into another, allowing you to make several small changes, and then bundle them up into one, more appropiate,
commit.
This get a bit complicated, when you start to make changes that aren&#x27;t in order.</p>
<p>Luckily, git has that solved, with <code>--fixup</code> and <code>--squash</code>. These let you commit changes, and at the same time specify that they should be part of a
previous commit.
The <code>fixup</code> option will allow you to <code>amend</code> a previous commit, and not change the original commit  message.
The <code>squash</code> options, will also <code>amend</code> a previous commit, but it will also give you the change to alter the commit message.</p>
<p>To use these, just prepare you staging area, like normal (<code>git add</code> or <code>git add -p</code>), then commit with:</p>
<pre><code>`git commit --fixup=&lt;previous commit hash&gt;`
</code></pre>
<p>This will create a new commit, with a message in the form</p>
<pre><code>!fixup &lt;original commit message&gt;
</code></pre>
<p>Then when you are at a stage you wish to squash and clean all your commits, just run a rebase with the <code>--autosquash</code> flag (or you can set
<code>rebase.autosquash</code> to true in you git config).</p>
<p>You history would then go from:</p>
<blockquote>
<p>commit 1234
<!-- -->        !fixup Original change</p>
</blockquote>
<blockquote>
<p>commit 5678
<!-- -->        Some other change</p>
</blockquote>
<blockquote>
<p>commit 91011
<!-- -->        Original change</p>
</blockquote>
<p>becoming:</p>
<blockquote>
<p>commit 5678
<!-- -->        Some other change</p>
<p>commit 91011
<!-- -->        Original change</p>
</blockquote>
<p>Where commit 91011, contains all the changes from the original <code>91011</code>, and <code>1234</code></p>
<p>Rebasing commits can sometimes be a little scary if you don&#x27;t know what you are doing or how it really works.
So squashing commits may not be for everyone, but I would still recommend everyone to put in more effort to their commit messages, as it can help
everyone involved in modifying a codebase.</p></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"POST":"Ensuring the git history of your project (or any version controlled project) can be an incredibly useful asset.\nIn particular for new developers, trying to understand why code has been written in a certain way.\nWith clear and ordered commit messages, it can become obvious as to why a change was made. \n\nThere are two practices I apply to make sure that I leave my code changes as clear as I can. \nThey are how I write the commit messages, and the\nordering of the actual commits.\n\n### Commit messages\nThe message in a commit is where an explanation for the change should reside.\nThis should include at the very least what was changed, and why.\n\nSome examples of a bad commit messages include (and yes, I have seen these kind of commits from multiple developers on different projects):\n\n\u003e fixed bug\n\nand\n\n\u003e refactored stuff\n\nA more descriptive commit message would look something like\n\n\u003e Fix ImageProcessingFactory not handling images less than 50px wide\n\nCommit messages should ideally tell you what a commit will do if it is applied.\nI try to write my messages as if being read as `This commit will \u003ccommit message\u003e`\n\nAn even better commit message would have a slightly longer message, after the initial message, describing the problem/change in more detail. \nHowever, this isn't always practical or even necessary depending on the project.\nIf you have a chance I would recommend taking a look at the git and linux kernal commit messages as examples of great ones!\n\nI've also worked in places that would prepend the ticket number to the commit message. Allowing developers to view the reasons for a change in more\ndetail.\n\n### Autosquashing commits\nRebasing commit allows you to keep your history linear. \nWhile not everyone agrees whether or not you should be maintaining a linear history, \nIt is almost definitely (in my opinion) and good idea to keep your local branches ordered appropriately, by showing changes as a series of changes to be applied.\nIdeally each change is isolated from the others (within reason), and can be applied separately.\n\nDevelopment rarely works like this. Too often have I made some changes, progressed a bit further, and realised I there were more changes to make in\nthat original commit.\nMaybe it was a left over debug statement, or some missing config, or even a chunk of functionality I didn't originally think about. \nTypically most people would just make a new commit with these changes, and leave it at that. \n\nGit has the ability to squash commits into another, allowing you to make several small changes, and then bundle them up into one, more appropiate,\ncommit.\nThis get a bit complicated, when you start to make changes that aren't in order.\n\nLuckily, git has that solved, with `--fixup` and `--squash`. These let you commit changes, and at the same time specify that they should be part of a\nprevious commit.\nThe `fixup` option will allow you to `amend` a previous commit, and not change the original commit  message.\nThe `squash` options, will also `amend` a previous commit, but it will also give you the change to alter the commit message.\n\nTo use these, just prepare you staging area, like normal (`git add` or `git add -p`), then commit with:\n\n    `git commit --fixup=\u003cprevious commit hash\u003e`\n\nThis will create a new commit, with a message in the form\n\n    !fixup \u003coriginal commit message\u003e\n\nThen when you are at a stage you wish to squash and clean all your commits, just run a rebase with the `--autosquash` flag (or you can set\n`rebase.autosquash` to true in you git config).\n\nYou history would then go from:\n\n\u003ecommit 1234\n\u003e\u003cbr\u003e \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;!fixup Original change\n\n\u003ecommit 5678\n\u003e\u003cbr\u003e \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Some other change\n\n\u003ecommit 91011\n\u003e\u003cbr\u003e \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Original change\n\nbecoming:\n\n\u003ecommit 5678\n\u003e\u003cbr\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; Some other change\n\u003e\n\u003ecommit 91011\n\u003e\u003cbr\u003e \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Original change\n\nWhere commit 91011, contains all the changes from the original `91011`, and `1234`\n\n\nRebasing commits can sometimes be a little scary if you don't know what you are doing or how it really works.\nSo squashing commits may not be for everyone, but I would still recommend everyone to put in more effort to their commit messages, as it can help\neveryone involved in modifying a codebase.\n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"maintaining-a-clean-git-history"},"buildId":"65UyYX_pAZroMRbCqWvbZ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>