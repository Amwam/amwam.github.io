<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1" data-next-head=""/><meta property="og:image" content="https://amwam.me/images/me.png" data-next-head=""/><link rel="manifest" href="/manifest.json" data-next-head=""/><link rel="alternate" type="application/rss+xml" title="RSS" href="https://amwam.me/rss.xml" data-next-head=""/><title data-next-head="">Optimising Docker builds with multi-stage targers | AMWAM - Amit Shah</title><meta property="og:url" content="https://amwam.me/blog/docker-multi-stage-targets" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Optimising Docker builds with multi-stage targers | AMWAM - Amit Shah" data-next-head=""/><meta property="og:image" content="https://amwam.me/images/me.png" data-next-head=""/><meta property="article:published_time" content="2024-07-04" data-next-head=""/><meta property="article:author" content="Amit Shah" data-next-head=""/><link rel="preload" href="/_next/static/chunks/dd9a78eca37df397.css" as="style"/><link rel="preload" href="/_next/static/chunks/274988711c50b9b5.css" as="style"/><link rel="stylesheet" href="/_next/static/chunks/dd9a78eca37df397.css" data-n-g=""/><link rel="stylesheet" href="/_next/static/chunks/274988711c50b9b5.css" data-n-p=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/9a04d3721f770a18.js" defer=""></script><script src="/_next/static/chunks/47a270e501e65340.js" defer=""></script><script src="/_next/static/chunks/28d7fb3b5b7550cd.js" defer=""></script><script src="/_next/static/chunks/181061b33a699bc3.js" defer=""></script><script src="/_next/static/chunks/turbopack-4a60034fd93a4310.js" defer=""></script><script src="/_next/static/chunks/72551891c21528a4.js" defer=""></script><script src="/_next/static/chunks/bc4441a87401806d.js" defer=""></script><script src="/_next/static/chunks/turbopack-87c3e0d3863916bc.js" defer=""></script><script src="/_next/static/65UyYX_pAZroMRbCqWvbZ/_ssgManifest.js" defer=""></script><script src="/_next/static/65UyYX_pAZroMRbCqWvbZ/_buildManifest.js" defer=""></script></head><body><div id="__next"><div class="_app-module__3RcuBW__container"><div id="Navigation-module__KYCJma__nav-bar" role="navigation"><img id="Navigation-module__KYCJma__nav-display-picture" src="/images/me.200.png" alt="Me (Amit)" loading="lazy"/><div id="Navigation-module__KYCJma__name">Amit Shah</div><div id="Navigation-module__KYCJma__nav-links"><div class="Navigation-module__KYCJma__nav-link"><a href="/">Home</a></div><div class="Navigation-module__KYCJma__nav-link"><a href="/about">About</a></div><div class="Navigation-module__KYCJma__nav-link"><a href="/blog">Blog</a></div><div class="Navigation-module__KYCJma__nav-link"><a href="/contact">Contact</a></div></div></div><div id="_app-module__3RcuBW__content-wrapper"><main id="_app-module__3RcuBW__content"><div><h1>Optimising Docker builds with multi-stage targers</h1><h4>4 July 2024</h4><div class="style-module__c7Ehta__tags"><span><a href="/blog?tag=docker">docker</a></span></div><p>I&#x27;ve found that one of the most powerful features in Docker is the ability to use multi-stage builds. This can significantly improve your development workflow and optimize your production containers, by allowing extra dependencies locally, without bloating the final production image.</p>
<h2>Understanding Multi-Stage Builds</h2>
<p>Multi-stage builds allow you to use multiple <code>FROM</code> statements in your Dockerfile. Each <code>FROM</code> instruction can use a different base, and each begins a new stage of the build. You can selectively copy artifacts from one stage to another, leaving behind everything you don&#x27;t want in the final image. You can also build specific <em>parts</em> of the Docker file, by specifying which target you wish to build. With this you can have a single Dockerfile for both development and production, without needing to duplicate their contents.</p>
<h2>Separating Dev and Prod Dependencies</h2>
<p>One of the key benefits of multi-stage builds is the ability to separate your development and production dependencies. This is particularly useful in Python projects where you often have different requirements for development (like testing and linting tools) and production.</p>
<p>Let&#x27;s look at an example Dockerfile:</p>
<pre><code class="language-dockerfile"># Stage 1: Base image for both dev and prod
FROM python:3.12 AS base

RUN pip install requests

# Stage 2: Production build
FROM base AS prod
ENV IS_PROD=true

# Stage 3: Development dependencies
FROM base AS dev
RUN pip install pytest

ENV IS_PROD=false
</code></pre>
<p>In this Dockerfile, we have three stages:</p>
<ol>
<li><code>base</code>: A common base stage with Python 3.12.</li>
<li><code>prod</code>: Includes only production dependencies.</li>
<li><code>dev</code>: Includes all dependencies (including development ones).</li>
</ol>
<h2>Building Specific Targets</h2>
<p>To build a specific target, you can use the <code>--target</code> flag:</p>
<pre><code class="language-bash"># Build the development image
docker build --target dev -t myapp:dev .

# Build the production image
docker build --target prod -t myapp:prod .
</code></pre>
<h2>Default Build Behavior</h2>
<p>It&#x27;s important to note that if you don&#x27;t specify a target, Docker will build the last stage by default. In our example, if you run <code>docker build .</code> without any flags, it will build the <code>dev</code> stage.</p>
<h2>Benefits of Multi-Stage Builds</h2>
<p>Let&#x27;s dive deeper into why using multi-stage builds is beneficial:</p>
<ol>
<li>
<p><strong>Smaller Production Images</strong>:</p>
<ul>
<li>By separating dev and prod dependencies, your production image only contains what&#x27;s necessary to run the application, resulting in a smaller image size.</li>
<li>A typical Python web application might require development tools like <code>pytest</code>, <code>flake8</code>, and <code>mypy</code>, which are not needed in production. By excluding these, you can reduce your image size.</li>
<li>This can be beneficial for services like AWS Fargate and AWS Lambda, as it reduces the load time for the services to download the container image.</li>
</ul>
</li>
<li>
<p><strong>Improved Security</strong>:</p>
<ul>
<li>Fewer dependencies in your production image means a reduced attack surface.</li>
<li>Example: Development tools often have their own dependencies and potential vulnerabilities. By excluding them from your production image, you minimize the risk of these vulnerabilities being exploited.</li>
<li>You can also use multi-stage builds to run security scans on your code before creating the final production image, ensuring that only vetted code makes it to production.</li>
</ul>
</li>
<li>
<p><strong>Faster Builds and Deployments</strong>:</p>
<ul>
<li>Smaller images are quicker to build, push, and pull, speeding up your CI/CD pipelines.</li>
<li>In a microservices architecture with dozens of services, reducing each container size by 100MB can save gigabytes of data transfer and storage, significantly speeding up deployments.</li>
<li>Faster builds mean quicker feedback loops for developers.</li>
</ul>
</li>
<li>
<p><strong>Consistency</strong>:</p>
<ul>
<li>Using the same base image for both development and production ensures consistency across environments.</li>
<li>This reduces &quot;it works on my machine&quot; problems by ensuring that the development environment closely mirrors production.</li>
</ul>
</li>
<li>
<p><strong>Flexibility</strong>:</p>
<ul>
<li>You can easily switch between development and production builds without maintaining separate Dockerfiles.</li>
<li>This simplifies your build process and reduces the chance of discrepancies between environments.</li>
</ul>
</li>
<li>
<p><strong>Optimized Build Cache</strong>:</p>
<ul>
<li>Multi-stage builds allow you to optimize your build cache more effectively.</li>
<li>You can structure your Dockerfile so that layers that change less frequently (like installing dependencies) are earlier in the file, while layers that change more often (like copying your application code) are later.</li>
<li>This means that subsequent builds can reuse cached layers more effectively, speeding up your build process.</li>
</ul>
</li>
<li>
<p><strong>Easy Integration of Build Tools</strong>:</p>
<ul>
<li>You can use specialized build tools or compilers in early stages without bloating your final image.</li>
</ul>
</li>
</ol>
<h2>Drawbacks</h2>
<p>One of the biggest drawbacks using multi-stage builds, is the inability to re-use sections in the middle of a stage.</p>
<p>For instance, typically I would want to have <code>dev</code> and <code>prod</code> images separated only by the dependencies they install. However to produce an optimise build, you would want to add you application code <em>after</em> building the dependencies. This would therefore mean you would have to duplicate the <code>COPY</code> commands in both the <code>dev</code> and <code>prod</code> stages.</p>
<p>Multi-stage builds in Docker offer a powerful way to optimize your container images and streamline your development workflow. By separating your dev and prod dependencies, you can ensure that your production containers are lean, secure, and efficient, while still maintaining a robust development environment.</p></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"POST":"I've found that one of the most powerful features in Docker is the ability to use multi-stage builds. This can significantly improve your development workflow and optimize your production containers, by allowing extra dependencies locally, without bloating the final production image.\n\n## Understanding Multi-Stage Builds\n\nMulti-stage builds allow you to use multiple `FROM` statements in your Dockerfile. Each `FROM` instruction can use a different base, and each begins a new stage of the build. You can selectively copy artifacts from one stage to another, leaving behind everything you don't want in the final image. You can also build specific *parts* of the Docker file, by specifying which target you wish to build. With this you can have a single Dockerfile for both development and production, without needing to duplicate their contents.\n\n## Separating Dev and Prod Dependencies\n\nOne of the key benefits of multi-stage builds is the ability to separate your development and production dependencies. This is particularly useful in Python projects where you often have different requirements for development (like testing and linting tools) and production.\n\nLet's look at an example Dockerfile:\n\n```dockerfile\n# Stage 1: Base image for both dev and prod\nFROM python:3.12 AS base\n\nRUN pip install requests\n\n# Stage 2: Production build\nFROM base AS prod\nENV IS_PROD=true\n\n# Stage 3: Development dependencies\nFROM base AS dev\nRUN pip install pytest\n\nENV IS_PROD=false\n```\n\nIn this Dockerfile, we have three stages:\n\n1. `base`: A common base stage with Python 3.12.\n2. `prod`: Includes only production dependencies.\n3. `dev`: Includes all dependencies (including development ones).\n\n## Building Specific Targets\n\nTo build a specific target, you can use the `--target` flag:\n\n```bash\n# Build the development image\ndocker build --target dev -t myapp:dev .\n\n# Build the production image\ndocker build --target prod -t myapp:prod .\n```\n\n## Default Build Behavior\n\nIt's important to note that if you don't specify a target, Docker will build the last stage by default. In our example, if you run `docker build .` without any flags, it will build the `dev` stage.\n\n## Benefits of Multi-Stage Builds\n\nLet's dive deeper into why using multi-stage builds is beneficial:\n\n1. **Smaller Production Images**: \n   - By separating dev and prod dependencies, your production image only contains what's necessary to run the application, resulting in a smaller image size.\n   - A typical Python web application might require development tools like `pytest`, `flake8`, and `mypy`, which are not needed in production. By excluding these, you can reduce your image size. \n   - This can be beneficial for services like AWS Fargate and AWS Lambda, as it reduces the load time for the services to download the container image.\n\n2. **Improved Security**: \n   - Fewer dependencies in your production image means a reduced attack surface.\n   - Example: Development tools often have their own dependencies and potential vulnerabilities. By excluding them from your production image, you minimize the risk of these vulnerabilities being exploited.\n   - You can also use multi-stage builds to run security scans on your code before creating the final production image, ensuring that only vetted code makes it to production.\n\n3. **Faster Builds and Deployments**: \n   - Smaller images are quicker to build, push, and pull, speeding up your CI/CD pipelines.\n   - In a microservices architecture with dozens of services, reducing each container size by 100MB can save gigabytes of data transfer and storage, significantly speeding up deployments.\n   - Faster builds mean quicker feedback loops for developers.\n\n4. **Consistency**: \n   - Using the same base image for both development and production ensures consistency across environments.\n   - This reduces \"it works on my machine\" problems by ensuring that the development environment closely mirrors production.\n\n5. **Flexibility**: \n   - You can easily switch between development and production builds without maintaining separate Dockerfiles.\n   - This simplifies your build process and reduces the chance of discrepancies between environments.\n\n6. **Optimized Build Cache**: \n   - Multi-stage builds allow you to optimize your build cache more effectively.\n   - You can structure your Dockerfile so that layers that change less frequently (like installing dependencies) are earlier in the file, while layers that change more often (like copying your application code) are later.\n   - This means that subsequent builds can reuse cached layers more effectively, speeding up your build process.\n\n7. **Easy Integration of Build Tools**: \n   - You can use specialized build tools or compilers in early stages without bloating your final image.\n\n\n## Drawbacks\n\nOne of the biggest drawbacks using multi-stage builds, is the inability to re-use sections in the middle of a stage.\n\nFor instance, typically I would want to have `dev` and `prod` images separated only by the dependencies they install. However to produce an optimise build, you would want to add you application code *after* building the dependencies. This would therefore mean you would have to duplicate the `COPY` commands in both the `dev` and `prod` stages.\n\n\nMulti-stage builds in Docker offer a powerful way to optimize your container images and streamline your development workflow. By separating your dev and prod dependencies, you can ensure that your production containers are lean, secure, and efficient, while still maintaining a robust development environment. \n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"docker-multi-stage-targets"},"buildId":"65UyYX_pAZroMRbCqWvbZ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>